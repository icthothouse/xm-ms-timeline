package com.icthh.xm.ms.timeline.repository.cassandra.mapper;

import com.datastax.driver.core.Row;
import com.icthh.xm.ms.timeline.domain.XmTimeline;

import java.time.Instant;
import java.util.Date;
import java.util.Map;

import lombok.experimental.UtilityClass;
import net.sf.uadetector.ReadableUserAgent;
import net.sf.uadetector.UserAgentStringParser;
import net.sf.uadetector.service.UADetectorServiceFactory;
import org.apache.commons.collections.MapUtils;
import org.apache.commons.lang3.StringUtils;

@UtilityClass
@SuppressWarnings("squid:S1118") // private constructor generated by lombok
public class TimelineMapper {

    private static UserAgentStringParser parser = UADetectorServiceFactory.getResourceModuleParser();

    /**
     * Convert cassandra row to timeline.
     *
     * @param row the cassandra row
     * @return timeline object
     */
    public static XmTimeline createTimeline(Row row) {
        XmTimeline timeline = new XmTimeline();
        timeline.setRid(getString(row, "rid"));
        timeline.setLogin(getString(row, "login"));
        timeline.setUserKey(getString(row, "user_key"));
        timeline.setTenant(getString(row, "tenant"));
        timeline.setMsName(getString(row, "ms_name"));
        timeline.setOperationName(getString(row, "operation"));
        timeline.setEntityId(getLong(row, "entity_id"));
        timeline.setEntityKey(getString(row, "entity_key"));
        timeline.setEntityTypeKey(getString(row, "entity_type_key"));
        timeline.setOperationUrl(getString(row, "operation_url"));
        timeline.setHttpMethod(getString(row, "http_method"));
        timeline.setHttpStatusCode(getInt(row, "http_status_code"));
        timeline.setStartDate(getInstant(row, "start_date"));
        timeline.setRequestBody(getString(row, "request_body"));
        timeline.setRequestLength(getLong(row, "request_length"));
        timeline.setResponseBody(getString(row, "response_body"));
        timeline.setRequestLength(getLong(row, "response_length"));
        timeline.setRequestHeaders(getMap(row, "request_headers"));
        timeline.setResponseHeaders(getMap(row, "response_headers"));
        timeline.setRequestLength(getLong(row, "exec_time"));
        timeline.setChannelType(getString(row, "channel_type"));

        parseUserAgent(timeline);
        return timeline;
    }

    private static void parseUserAgent(XmTimeline timeline) {
        if (MapUtils.isNotEmpty(timeline.getRequestHeaders())) {
            String ua = timeline.getRequestHeaders().get("user-agent");
            if (StringUtils.isNotBlank(ua)) {
                ReadableUserAgent agent = parser.parse(ua);
                timeline.setBrowser(agent.getName() + " " + agent.getVersionNumber().toVersionString());
                timeline.setOpSystem(agent.getOperatingSystem().getName() + " "
                    + agent.getOperatingSystem().getVersionNumber().toVersionString());
            }
        }
    }

    private static String getString(Row row, String column) {
        if (row.getColumnDefinitions().contains(column)) {
            return row.getString(column);
        }
        return null;
    }

    private static Long getLong(Row row, String column) {
        if (row.getColumnDefinitions().contains(column)) {
            return row.getLong(column);
        }
        return null;
    }

    private static Integer getInt(Row row, String column) {
        if (row.getColumnDefinitions().contains(column)) {
            return row.getInt(column);
        }
        return null;
    }

    private static Instant getInstant(Row row, String column) {
        if (row.getColumnDefinitions().contains(column)) {
            Date date = row.getTimestamp(column);
            return date != null ? date.toInstant() : null;
        }
        return null;
    }

    private static Map<String, String> getMap(Row row, String column) {
        if (row.getColumnDefinitions().contains(column)) {
            return row.getMap(column, String.class, String.class);
        }
        return null;
    }
}
